4 февраля

4 парадигмы С++:
	1. ООП
	2. Структурное программирование
	3. Функциональное программирование
	4. Метапрограммирование
	
Система контроля версий позволяет сохранять программу в процессе разработки и при необходимости позволяет вернуться к предыдущему стабильно работающему состоянию. Это некая "подстраховка"
 
Основные взаимодействия с git:
	1. git clone - связать оригинальынй репозиторий с моим компьютером и создать его локальную копию (соединене происходит через ssh)
	2. git pull - обновить локальный репозиторий до оригинального репозитория
	3. git add - отметить измененные файлы в локальном репозитории, который позже войдут в коммит
	4. git commit -m - создание коммита, т.е. некоторой контрольной и сохраненной точки проекта. (-m позволяет дать краткий комментарий)
	5. git push - отправляет все локальные коммиты в оригинальный репозиторий.
	

<chrono> - библиотека для работы со временем
timestamp - количество секунд с начала эпохи UNIX - int
duration - разность ts- временной интервал
Часы:
    system_clock
    steady_clock - гарантированное возрастание
    high_resolution_clock - самые точные часы


КОНТЕЙНЕРЫ:
    I. Гомогенные, т.е. хранят один и тот же тип
        1. На основе массива:
            a. vector
            b. array
            c. deque
            d. string

        2. Узловые:
            a. list
            b. forward_list

        3. На основе деревьев (красно-черное):
            a. set, multiset
            b. map, multimap

        4. На основе хэш-таблиц:
            a. unordered_set(multiset)
            b. unordered_map(multimap)

        5. Адаптеры (обёртки):
            a. stack LIFO
            b. queue FIFO
            c. priority_queue

    II. Гетерогенные:
        1. pair
        2. tuple

Variadic templates :
    template <typename .. Types>
    ..Types



11 февраля

КОНТЕЙНЕРЫ на основе массива (подробнее)
	1. std::vector
		- Динамически меняет размер
		- По умолчанию
		- Добавляет в конец за О(1) (push_back()), в начало или поиск элемента О(n)
		- Объект - сущность, обладающая поведением и состоянием
		- size - количество лежащих элементов там
		- capacity - количество зарезервированной памяти
		- Логично, что size <= capacity
		- resize()
		- empace_back() - в качестве аргумента принимает конструктор на объект и потом его создает
		
	2. std::string
		- Не совсем контейнер
	3. std::array
		- Статический фиксированный размер
		- Лежит на стеке
		- Редко используем
		- std::array<type, size> name = {} (инициализация по умолчанию)
	4. std::deque 
		- Добавление в конец (push_back()) и начало (push_front()) за О(1)
		- empace_back(), empace_front()
	
УЗЛОВЫЕ КОНТЕЙНЕРЫ:
	1. std::list, std::forward_list
		- Имея указатель на элемент, добавление и удаление происходят за О(1)
		- Перемещение элементов
		- Деление листа на части
		- Хорошо работает сортировка merge (сортировка слиянием, гарантированно О(n log(n))), ведь нет копирования элементов
		- std::sort - это merge + insertions
		- Особенные функции листов:
			а) splice() - перемещение элементов из одного в другой
			б) merge() - слияние двух отсортированных листов
			в) метод sort()
		
АССОЦИАТИВНЫЕ КОНТЕЙНЕРЫ:
	1. set (Красно-черное дерево)
		- множество
		- Уникальные элементы
		- Отсортированы 
		- Добавление/поиск О(logN)
		
	2. multiset 
		- то же самое что и set, но без уникальности
	3. unordered_set (хэш-таблица) 
		- set без сортировки
		- Добавление/поиск за О(1)
	4. unordered_multiset
		- то же самое, но без сортировки и уникальности
	5. map(multimap, unordered_map, unordered_multimap)
		- набор пар ключ/значение
		- для ключей свойства соответствуют set
		- элементы std::pair
		- Есть функция std::make_pair
		- если обратиться к несуществующему ключу, то создастся искомый ключ по умолчанию, т.е. ошибки не выдаст
		- Существует функция emplace
		- lower_bound - возвращает итератор на нижнюю границу искомого элемента
		- std::equal_range - возвращает два итератора - границу между lower_bound и upper_bound
		
ГЕТЕРОГЕННЫЕ КОНТЕЙНЕРЫ:
	1. tuple
		- Есть сравнение лексикографически
		

Итересные фишки:
	- std::copy(numbers.begin(), numbers.end(), std::ostream_iterator<int>(std::cout, " ")) - так можно вывести лист
	- std::setw(8) << std::setfill('0') - для вывода, следующий вывод дозаполнится нулями до трех элементов
	
	
	
18 февраля:

АЛГОРИТМЫ И ИТЕРАТОРЫ

Библиотека <random>
	1. Наилучший ГПСЧ - вихрь Мерсенна (mersenne_twister_engine)
	2. std::mt19937 - вихрь Мерсенна с оптимальными коэффициентами, лучше использовать его 
	3. Seed - это буквально стартовое число, с помощью которого алгоритм выдает следующее число (нужное нам число).
	   Примечательно, что с одним и тем же seed алгоритм выдаст одно и то же число. 
	   В качестве seed удобно брать текущее время, ведь оно всегда меняется. Например, std::chrono::steady_clock::now().time_since_epoch().count() 
	4. Генератор (На вход нужен seed) - источник случайности, представлен алгоритмами для гпсч
	5. Распределение - закон, которому подчиняются элементы, плотность вероятности.

Итератор - это объект, который предоставляет последовательный или поэлементный доступ к контейнеру.
	std::begin - итератор на первый элемент контейнера
	std::end - итератор на следующий за последним элемент
	std::back_inserter - итератор вставки (оборачивает push_back)
	std::inserter - вставка в произвольное место
	
Операции с итераторами:
	1. std::next
	2. std::prev
	3. std::distance

Диапазон (до С++20) - это набор из двух итераторов на один контейнера, для которых 1 указывает на элемент "левее" чем второй.

Главный плюс в использовании итераторов при работе с алгоритмами на контейнерах:
	- Нет необходимости знать структуру контейнера целиком, можно работать лишь с конкретным диапазоном
	- Более того, работа с итераторами на всех контейнерах одинакова в силу того, что для итераторов переопределены операции +,- и т.д

Почему operator<< принимает и отдаёт ссылку? Такое устройство оператора позволяет выводить последовательно несколько элементов.

Число pi можно записать как std::acos(-1)

Библиотека <numeric>:
	1. std::gcd - НОД
	2. std::lcm - НОК
	3. std::iota - Последовательность
	4. std::accumulate - Применение бинарной операции последовательно к элементам
	5. std::inner_product - Скалярное произведение
	
ТИПЫ АЛГОРИТМОВ:
	1. Модифицирующие
	2. Немодифицирующие
	3. Алгоритмы разделения (partition)
	4. Для работы с отсортированными диапазонами
	
Библиотека <algorithm>
	1. std::reverse_copy - это std::copy развернутого диапазона
	2. std::reverse - развернуть диапазон
	3. std::transform - применение к каждому элементу диапазона унарной операции или к каждой паре элементов двух диапазонов бинарной операции
	4. std::generate_n - генерация элементов
	5. std::nth_element - располагает n-ный элемент на своё место в отсортированном диапазоне
	6. std::unique - перемещает повторы последовательности в конце и возвращает итератор на 1-й из них
	
	
	
	
	
4 марта.

Файловая система
	1. <filesystem>
	2. std::filesystem - своё пространство имен
	3. path - класс пути
		- is_directory() - является ли директорией
		- stem (Например, для main.cpp "main" - это stem)
		- extension (Например, для main.cpp "cpp" - это extension)
		- absolute(path) - абсолютный путь
		- relative(path) - относительный путь
		- std::filesystem::remove(path) - удалит файл по его пути
	4. std::filesystem::directory_iterator - итераторы по директории
		- Позволяет обходить директории
		- ->path() - содержит в себе путь до файла
		
		
JSON - JavaScript Object Notation (альтернатива XML)
	! Это некий единый формат структур данных
	! Используется для хранения, передачи и обмена структурированных данных, является связующим звеном между структурами данных
	  из разных языков программирования (например, map(c++) -> json -> dict(python)).
	JS: Object - состоит из пар "ключ - значение" (значение может быть любого типа)
	1. Создание JSON на основе map/vector
	2. Преобразование в строку (функция dump())
	3. Парсинг из строки
	4. Итерация, задание содержимого вручную
	
	
	
Регулярки <regex> (Python: import re)
	1. std::regex - паттерн
	2. regex_search - поиск паттернов
	3. regex_replace - заменяет вхождения
	4. sregex_iterator - предоставляет итератор на вхождение (буква s перед regex от слова string)
	5. 2 итератора:
		Первый - начало стр., конец стр., шаблон
		Второй - пустой
	   => Итерация по найденным объектам
	   Чтобы ->std::string => метод .str() 
	   
	   
	   
	   
	   
	   
	   
11 марта

!Перед распараллеливанием:
	-Нужно ли распараллеливать?
	-Можно ли распараллелить?


ПАРАЛЛЕЛИЗМ:
	I. Через процессы:
		- 1 процесс - 1 ядро (в один момент времени), но обычно процессов больше, чем ядер, => переключение контекста (contex switch)
		- Переключение контекста - исполнитель работает в течение процессорного времени, а затем состояние процесса консервируется, и он снова отправляется в "очередь"
	
	II. Через потоки:
		- Как процессы, но делят память с другими потоками
		- Одному процессу соответствует 1 или более потоков
		- Это быстрее, дешевле, но менее безопасно
		- !Есть проблема: общие ресурсы
		- На С++ std::thread и std::future:
		A. std::thread:
			! Нельзя получить результат
			- 1 объект - это один поток
			- Получает функцию и автономно её выполняет
			- Если не закончит раньше, чем родителя - умрёт => можно его подождать (join()) или отпустить отдельно (detached())
		B. std::future:
			! Можно получить результат
			- Контракт на выполнение результата
			- Получает функцию
			- Можно потребовать результат в любой момент
			- Могут начать работать в последний момент => можно требовать немедленного начала
			
		- Передача: имя функции, потом аргументы
		- Передача ссылок
		- Передача методов класса
		
		
#Почему нельзя сделать operator>> методом класса? Потому что operator>> первым аргументом просит std::istream&, а у методов класса неявный первый аргумент this
	
#a/b - округление вниз, (a+b-1)/b - округление вверх
	





18 марта.


СИНХРОНИЗАЦИЯ
-конкуренция за владение общим ресурсом
	1. Терминология: состояние гонки (race condition)
	Решение: "выключатель" или "табличка"
	"Mutrual exlusion" - C++:std::mutex
		- lock() - выключить/заблокировать для других потоков
		- unlock() - включить


	2. Тупик (deadlock) - если два или более мьютекса
		- Потоки блокируют друг друга
		- Например, случается, если 2 мьютекса блокируются в разном порядке
		Решение(С++):
			- Функция std::lock (до С++17) - берет два мьютекса и следит за ними пристально
			- Класс std::scoped_losk (с С++)


АТОМАРНЫЕ ПЕРЕМЕННЫЕ <atomic>:
	- Действие, которое на уровне процессора выполняется за 1 действие
	- Переменные, действия с которыми является атомарными - атомарные
	- Определение 1 не совсем корректно, операции "выглядят снаружи, как атомарные"


RAII: Resource Allocation is Initialization
{
	RAII - обертка (mutex);
	дейтсвие ;
}
std::lock_guard;
srd::unique_lock;
+std::defer_lock (не забирает mutex сразу)

Стек - каждому процессу соответсвует своя обл.памяти
Регистры - ячейки памяти, с которомы процессор может совершать операции

!Операция сложения выполняется не в одно действие:
	- Скопировать в регистр
	- Сложить
	- Скопировать обратно


ГРАНУЛЯРНОСТЬ (крупная или мелкая) - оценка кол-ва действий, являющихся потокобезопасными 

	
	
	
	
1 АПРЕЛЯ

Как компьютер соединен с интернетом?
	- Ethernert, wi-fi, ..G(mobile)

"Свод" неких правил, по которым осуществляется соединение и передача информации - TCP/IP

Router - пункт связи и сортировки

Пакет - набор битов, кусочек информации

На пакете есть контрольное число - число прохождений через роутеры. Если число прохождений > контрольное число, то считается, что пакет затерялся и удаляется.

Как происходит передача информации между устройствами в сети Интернет?
	1. Начальный узел отправляет пакет информации, но котором как на почтовой открытке указана информация адресата.
	2. Пакет проходит несколько пунктов сортировки (не больше чем контрольное число)
	3. Пакет доходит до получателя, получатель обрабатывает информацию.

Если передаваемая информация слишком большая (например, видео), то она дробиться по нескольким последовательным пакетам, которые передаются по отдельности.
Из-за этого разбиения на маленькие пакеты, при передачи больших объёмов данных по Интернету не задерживается обмен данными между другими устройствами в сети.

Ipv4-адрес, представлен в виде (0-255).(0-255).(0-255).(0-255)	
Порт (число 0-65535):
	- 80 - HTTP
	- 433 - HTTPS
	- 22 - SSH

IP - адреса:
	- Белые - абсолютный адрес клиента
	- Серые - адреса в подсети провайдера (обычно начинаются с 10.2.)

Локальное ip - адрес в сети wi-fi-роутера (чаще всего 192.168.)

tracert - для windows - отследить путь пакета

Основные термины:
	1. ip
	2. port
	3. socket - узел соединения:
		a. TCP 1 <--> 1 - гарантированная доставка информации, соединение один на один
		b. UDP 1 -> - не гарантирует доставку информации, соединение от 1 к многим, потоковое вещание (например, трансляция)
	
Схема:
	1. Локал. ip : "localhost", "127.0.01"
	2. port (10000 - ..., чтобы не задеть зарезервированные порты)
	
	
	
	
	
	
	
8 АПРЕЛЯ

Python embedding:
1. Вызов готового скрипта
2. Вызов функции "по всем правилам"
	 
		
		
		
		
		
		
		
		
		
		
