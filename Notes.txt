4 февраля

4 парадигмы С++:
	1. ООП
	2. Структурное программирование
	3. Функциональное программирование
	4. Метапрограммирование
	
Система контроля версий позволяет сохранять программу в процессе разработки и при необходимости позволяет вернуться к предыдущему стабильно работающему состоянию. Это некая "подстраховка"
 
Основные взаимодействия с git:
	1. git clone - связать оригинальынй репозиторий с моим компьютером и создать его локальную копию (соединене происходит через ssh)
	2. git pull - обновить локальный репозиторий до оригинального репозитория
	3. git add - отметить измененные файлы в локальном репозитории, который позже войдут в коммит
	4. git commit -m - создание коммита, т.е. некоторой контрольной и сохраненной точки проекта. (-m позволяет дать краткий комментарий)
	5. git push - отправляет все локальные коммиты в оригинальный репозиторий.
	

<chrono> - библиотека для работы со временем
timestamp - количество секунд с начала эпохи UNIX - int
duration - разность ts- временной интервал
Часы:
    system_clock
    steady_clock - гарантированное возрастание
    high_resolution_clock - самые точные часы


КОНТЕЙНЕРЫ:
    I. Гомогенные, т.е. хранят один и тот же тип
        1. На основе массива:
            a. vector
            b. array
            c. deque
            d. string

        2. Узловые:
            a. list
            b. forward_list

        3. На основе деревьев (красно-черное):
            a. set, multiset
            b. map, multimap

        4. На основе хэш-таблиц:
            a. unordered_set(multiset)
            b. unordered_map(multimap)

        5. Адаптеры (обёртки):
            a. stack LIFO
            b. queue FIFO
            c. priority_queue

    II. Гетерогенные:
        1. pair
        2. tuple

Variadic templates :
    template <typename .. Types>
    ..Types



11 февраля

КОНТЕЙНЕРЫ на основе массива (подробнее)
	1. std::vector
		- Динамически меняет размер
		- По умолчанию
		- Добавляет в конец за О(1) (push_back()), в начало или поиск элемента О(n)
		- Объект - сущность, обладающая поведением и состоянием
		- size - количество лежащих элементов там
		- capacity - количество зарезервированной памяти
		- Логично, что size <= capacity
		- resize()
		- empace_back() - в качестве аргумента принимает конструктор на объект и потом его создает
		
	2. std::string
		- Не совсем контейнер
	3. std::array
		- Статический фиксированный размер
		- Лежит на стеке
		- Редко используем
		- std::array<type, size> name = {} (инициализация по умолчанию)
	4. std::deque 
		- Добавление в конец (push_back()) и начало (push_front()) за О(1)
		- empace_back(), empace_front()
	
УЗЛОВЫЕ КОНТЕЙНЕРЫ:
	1. std::list, std::forward_list
		- Имея указатель на элемент, добавление и удаление происходят за О(1)
		- Перемещение элементов
		- Деление листа на части
		- Хорошо работает сортировка merge (сортировка слиянием, гарантированно О(n log(n))), ведь нет копирования элементов
		- std::sort - это merge + insertions
		- Особенные функции листов:
			а) splice() - перемещение элементов из одного в другой
			б) merge() - слияние двух отсортированных листов
			в) метод sort()
		
АССОЦИАТИВНЫЕ КОНТЕЙНЕРЫ:
	1. set (Красно-черное дерево)
		- множество
		- Уникальные элементы
		- Отсортированы 
		- Добавление/поиск О(logN)
		
	2. multiset 
		- то же самое что и set, но без уникальности
	3. unordered_set (хэш-таблица) 
		- set без сортировки
		- Добавление/поиск за О(1)
	4. unordered_multiset
		- то же самое, но без сортировки и уникальности
	5. map(multimap, unordered_map, unordered_multimap)
		- набор пар ключ/значение
		- для ключей свойства соответствуют set
		- элементы std::pair
		- Есть функция std::make_pair
		- если обратиться к несуществующему ключу, то создастся искомый ключ по умолчанию, т.е. ошибки не выдаст
		- Существует функция emplace
		- lower_bound - возвращает итератор на нижнюю границу искомого элемента
		- std::equal_range - возвращает два итератора - границу между lower_bound и upper_bound
		
ГЕТЕРОГЕННЫЕ КОНТЕЙНЕРЫ:
	1. tuple
		- Есть сравнение лексикографически
		

Итересные фишки:
	- std::copy(numbers.begin(), numbers.end(), std::ostream_iterator<int>(std::cout, " ")) - так можно вывести лист
	- std::setw(8) << std::setfill('0') - для вывода, следующий вывод дозаполнится нулями до трех элементов
	
	
	
18 февраля:

АЛГОРИТМЫ И ИТЕРАТОРЫ

Библиотека <random>
	1. Наилучший ГПСЧ - вихрь Мерсенна (mersenne_twister_engine)
	2. std::mt19937 - вихрь Мерсенна с оптимальными коэффициентами, лучше использовать его 
	3. Seed - это буквально стартовое число, с помощью которого алгоритм выдает следующее число (нужное нам число).
	   Примечательно, что с одним и тем же seed алгоритм выдаст одно и то же число. 
	   В качестве seed удобно брать текущее время, ведь оно всегда меняется. Например, std::chrono::steady_clock::now().time_since_epoch().count() 
	4. Генератор (На вход нужен seed) - источник случайности, представлен алгоритмами для гпсч
	5. Распределение - закон, которому подчиняются элементы, плотность вероятности.

Итератор - это объект, который предоставляет последовательный или поэлементный доступ к контейнеру.
	std::begin - итератор на первый элемент контейнера
	std::end - итератор на следующий за последним элемент
	std::back_inserter - итератор вставки (оборачивает push_back)
	std::inserter - вставка в произвольное место
	
Операции с итераторами:
	1. std::next
	2. std::prev
	3. std::distance

Диапазон (до С++20) - это набор из двух итераторов на один контейнера, для которых 1 указывает на элемент "левее" чем второй.

Главный плюс в использовании итераторов при работе с алгоритмами на контейнерах:
	- Нет необходимости знать структуру контейнера целиком, можно работать лишь с конкретным диапазоном
	- Более того, работа с итераторами на всех контейнерах одинакова в силу того, что для итераторов переопределены операции +,- и т.д

Почему operator<< принимает и отдаёт ссылку? Такое устройство оператора позволяет выводить последовательно несколько элементов.

Число pi можно записать как std::acos(-1)

Библиотека <numeric>:
	1. std::gcd - НОД
	2. std::lcm - НОК
	3. std::iota - Последовательность
	4. std::accumulate - Применение бинарной операции последовательно к элементам
	5. std::inner_product - Скалярное произведение
	
ТИПЫ АЛГОРИТМОВ:
	1. Модифицирующие
	2. Немодифицирующие
	3. Алгоритмы разделения (partition)
	4. Для работы с отсортированными диапазонами
	
Библиотека <algorithm>
	1. std::reverse_copy - это std::copy развернутого диапазона
	2. std::reverse - развернуть диапазон
	3. std::transform - применение к каждому элементу диапазона унарной операции или к каждой паре элементов двух диапазонов бинарной операции
	4. std::generate_n - генерация элементов
	5. std::nth_element - располагает n-ный элемент на своё место в отсортированном диапазоне
	6. std::unique - перемещает повторы последовательности в конце и возвращает итератор на 1-й из них
	
		
		
		
		
		
		
		
		
		
		
